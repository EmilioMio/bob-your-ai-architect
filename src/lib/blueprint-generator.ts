import { GeneratedArchitecture, ProjectFormData } from '@/components/builder/types';

export interface Blueprint {
  version: string;
  generatedAt: string;
  projectName: string;
  projectType: string;
  description: string;
  team: {
    size: string;
    experience: string;
    timeline: string;
  };
  techStack: Record<string, string | undefined>;
  fileStructure: {
    frontend?: object;
    backend?: object;
    mobile?: object;
  };
  database?: {
    required: boolean;
    type: string;
    tables: Array<{
      name: string;
      columns: Array<{
        name: string;
        type: string;
        primaryKey?: boolean;
        unique?: boolean;
        foreignKey?: string;
      }>;
    }>;
    relationships: Array<{
      from: string;
      to: string;
      type: string;
      foreignKey: string;
    }>;
  };
  apiEndpoints?: Array<{
    method: string;
    path: string;
    purpose: string;
    auth: boolean;
  }>;
  architectureRules: Array<{
    category: string;
    rules: string[];
  }>;
  agentRecommendations: Array<{
    agent: string;
    summary: string[];
    reasoning?: string;
    estimate?: string | null;
  }>;
  toolRecommendations: Array<{
    name: string;
    purpose: string;
    reason: string;
  }>;
  tradeoffs?: {
    conflict: string;
    decision: string;
    reasoning: string;
  };
}

export function generateBlueprint(
  architecture: GeneratedArchitecture,
  formData: ProjectFormData
): Blueprint {
  // Convert TechStack to Record<string, string | undefined>
  const techStackRecord: Record<string, string | undefined> = {};
  if (architecture.techStack.frontend) techStackRecord.frontend = architecture.techStack.frontend;
  if (architecture.techStack.backend) techStackRecord.backend = architecture.techStack.backend;
  if (architecture.techStack.database) techStackRecord.database = architecture.techStack.database;
  if (architecture.techStack.authentication) techStackRecord.authentication = architecture.techStack.authentication;
  if (architecture.techStack.deployment) techStackRecord.deployment = architecture.techStack.deployment;
  if (architecture.techStack.caching) techStackRecord.caching = architecture.techStack.caching;
  if (architecture.techStack.storage) techStackRecord.storage = architecture.techStack.storage;

  return {
    version: '1.0.0',
    generatedAt: new Date().toISOString(),
    projectName: architecture.projectName,
    projectType: architecture.projectType,
    description: formData.project,
    team: {
      size: formData.teamSize,
      experience: formData.experience,
      timeline: formData.timeline,
    },
    techStack: techStackRecord,
    fileStructure: {
      frontend: architecture.fileStructure.frontend,
      backend: architecture.fileStructure.backend,
      mobile: architecture.fileStructure.mobile,
    },
    database: architecture.database?.required ? {
      required: true,
      type: architecture.database.type,
      tables: architecture.database.tables,
      relationships: architecture.database.relationships,
    } : undefined,
    apiEndpoints: architecture.apiEndpoints,
    architectureRules: architecture.architectureRules.map(rule => ({
      category: rule.category,
      rules: rule.rules,
    })),
    agentRecommendations: architecture.agentDecisions.map(agent => ({
      agent: agent.name,
      summary: agent.summary,
      reasoning: agent.reasoning,
      estimate: agent.estimate,
    })),
    toolRecommendations: architecture.toolRecommendations.map(tool => ({
      name: tool.name,
      purpose: tool.purpose,
      reason: tool.reason,
    })),
    tradeoffs: architecture.tradeoffResolution ? {
      conflict: architecture.tradeoffResolution.conflict,
      decision: architecture.tradeoffResolution.decision,
      reasoning: architecture.tradeoffResolution.reasoning,
    } : undefined,
  };
}

export function generateReadme(blueprint: Blueprint): string {
  return `# ${blueprint.projectName}

## Overview
${blueprint.description}

## Project Type
${blueprint.projectType}

## Team
- **Size**: ${blueprint.team.size}
- **Experience**: ${blueprint.team.experience}
- **Timeline**: ${blueprint.team.timeline}

## Tech Stack
${Object.entries(blueprint.techStack)
  .filter(([_, v]) => v)
  .map(([k, v]) => `- **${k}**: ${v}`)
  .join('\n')}

## Getting Started

\`\`\`bash
# Install dependencies
npm install

# Run development server
npm run dev

# Build for production
npm run build
\`\`\`

## Architecture
This project follows the architecture defined in \`blueprint.json\`.
See [ARCHITECTURE.md](./ARCHITECTURE.md) for detailed guidelines.

---
*Generated by Bob the Architect on ${new Date().toLocaleDateString()}*
`;
}

export function generateArchitectureDocs(blueprint: Blueprint): string {
  let docs = `# Architecture Guidelines

## Overview
${blueprint.description}

## File Structure Rules

`;

  for (const category of blueprint.architectureRules) {
    docs += `### ${category.category}\n`;
    for (const rule of category.rules) {
      docs += `- ${rule}\n`;
    }
    docs += '\n';
  }

  docs += `## Agent Recommendations\n\n`;

  for (const agent of blueprint.agentRecommendations) {
    docs += `### ${agent.agent}\n`;
    for (const item of agent.summary) {
      docs += `- ${item}\n`;
    }
    if (agent.reasoning) {
      docs += `\n*${agent.reasoning}*\n`;
    }
    if (agent.estimate) {
      docs += `\n**Estimated cost**: ${agent.estimate}\n`;
    }
    docs += '\n';
  }

  docs += `## Tool Recommendations\n\n`;

  for (const tool of blueprint.toolRecommendations) {
    docs += `### ${tool.name}\n`;
    docs += `- **Purpose**: ${tool.purpose}\n`;
    docs += `- **Why**: ${tool.reason}\n\n`;
  }

  if (blueprint.tradeoffs) {
    docs += `## Trade-off Decisions\n\n`;
    docs += `**Conflict**: ${blueprint.tradeoffs.conflict}\n`;
    docs += `**Decision**: ${blueprint.tradeoffs.decision}\n`;
    docs += `**Reasoning**: ${blueprint.tradeoffs.reasoning}\n`;
  }

  docs += `\n---\n*Generated by Bob the Architect on ${new Date().toLocaleDateString()}*\n`;

  return docs;
}

export function generateDatabaseDocs(blueprint: Blueprint): string | null {
  if (!blueprint.database) return null;

  let docs = `# Database Schema

## Type: ${blueprint.database.type}

## Tables

`;

  for (const table of blueprint.database.tables) {
    docs += `### ${table.name}\n`;
    docs += `| Column | Type | Constraints |\n`;
    docs += `|--------|------|-------------|\n`;
    
    for (const col of table.columns) {
      const constraints = [
        col.primaryKey && 'PK',
        col.unique && 'UNIQUE',
        col.foreignKey && `FK â†’ ${col.foreignKey}`
      ].filter(Boolean).join(', ') || '-';
      
      docs += `| ${col.name} | ${col.type} | ${constraints} |\n`;
    }
    docs += '\n';
  }

  if (blueprint.database.relationships.length > 0) {
    docs += `## Relationships\n\n`;
    for (const rel of blueprint.database.relationships) {
      docs += `- **${rel.from}** ${rel.type} **${rel.to}** via \`${rel.foreignKey}\`\n`;
    }
  }

  docs += `\n---\n*Generated by Bob the Architect on ${new Date().toLocaleDateString()}*\n`;

  return docs;
}

export function generateApiDocs(blueprint: Blueprint): string | null {
  if (!blueprint.apiEndpoints || blueprint.apiEndpoints.length === 0) return null;

  let docs = `# API Documentation

## Endpoints

`;

  for (const endpoint of blueprint.apiEndpoints) {
    docs += `### ${endpoint.method} ${endpoint.path}\n`;
    docs += `- **Purpose**: ${endpoint.purpose}\n`;
    docs += `- **Authentication Required**: ${endpoint.auth ? 'Yes ðŸ”’' : 'No'}\n\n`;
  }

  docs += `---\n*Generated by Bob the Architect on ${new Date().toLocaleDateString()}*\n`;

  return docs;
}
